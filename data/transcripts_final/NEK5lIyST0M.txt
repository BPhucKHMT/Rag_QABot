0:00:14 - 0:00:21, Chúng ta đã cùng tìm hiểu về mô hình dựa trên gradient tổng quát và chúng ta có 3 công việc cần phải làm.
0:00:21 - 0:00:42, Công việc đầu tiên là xác định hàm dự đoán y ngã là bằng f x theta, sau đó xác định hàm lỗi là g của theta, trong đó nhận dữ kiện xi, chính là dữ liệu huấn luyện.
0:00:42 - 0:00:54, Công việc cuối cùng là tìm theta sao cho hàm j là nhỏ nhất.
0:00:54 - 0:01:06, Công việc số 3 này đã có 1 công cụ là gradient descent và thuật toán backpropagation.
0:01:06 - 0:01:18, Công việc 2 này đã được tích hợp trong deep learning framework.
0:01:18 - 0:01:28, Từ nay về sau, chúng ta chỉ tập trung vào 2 công việc đầu, đó là thiết kế và xác định hàm lỗi.
0:01:28 - 0:01:34, Một số hàm dựa trên gradient cơ bản chúng ta có thể liệt kê ở đây.
0:01:34 - 0:01:48, Đầu tiên là mô hình dữ liệu đầu ra, nó có mối quan hệ phụ thuộc một cách tuyến tính x, nó chia ra làm 2 loại bài toán.
0:01:48 - 0:01:58, Bài toán đầu tiên là hồi quy. Hồi quy thì nếu như một số tài liệu hoặc là một số bạn có thể phát biểu đó là
0:01:58 - 0:02:07, giá trị đầu ra của mình là giá trị liên tục, còn bài toán phân loại thì giá trị đầu ra y của mình sẽ là giá trị rời rạc.
0:02:07 - 0:02:14, Tuy nhiên cách định nghĩa như vậy sẽ không toàn diện và khó cho chúng ta trong một số tình huống.
0:02:14 - 0:02:20, Ví dụ như bài toán đoán tuổi, chúng ta sẽ không biết đó là bài toán hồi quy hay đó là bài toán phân loại.
0:02:20 - 0:02:27, Tại vì tuổi của mình có thể là một số thuộc một tập hợp từ 0 cho đến 200. Ví dụ vậy.
0:02:27 - 0:02:37, Thế thì chúng ta sẽ có một cách định nghĩa khác, nó sẽ tổng quát hơn. Đó là bài toán hồi quy là bài toán đầu ra của mình là y.
0:02:37 - 0:02:45, Nếu như chúng ta có hai giá trị y1 và y2 mà chúng ta thấy nó có tính thứ tự thì đó là bài toán hồi quy.
0:02:45 - 0:02:51, Thế nào có tính thứ tự? Chúng ta có thể đặt được các dấu bé, dấu lớn và dấu bằng.
0:02:51 - 0:03:00, Ví dụ bài toán đoán tuổi thì chúng ta có thể đặt các dấu đó là 6 tuổi thì là bé hơn 12 tuổi.
0:03:00 - 0:03:06, 6 tuổi thì lớn hơn 3 tuổi, ví dụ vậy. Đó là giá trị output của mình có tính thứ tự.
0:03:06 - 0:03:19, Thì đó là bài toán hồi quy. Còn nếu cái output của mình, nếu hai giá trị y1 và y2 mà nó chỉ có thể đặt được dấu bằng hoặc dấu khác thì lúc đó là không có tính thứ tự.
0:03:19 - 0:03:27, Ví dụ như bài toán dự đoán đồ vật là chó, mèo, gà, vịt thì mèo thì là bằng mèo.
0:03:27 - 0:03:32, Mèo sẽ khác chó chứ không thể nào mà mèo nhỏ hơn chó hoặc là mèo lớn hơn chó.
0:03:32 - 0:03:37, Thì đó là cái cách để chúng ta có thể biết đó là bài toán hồi quy hay bài toán tuyến tính.
0:03:37 - 0:03:44, Thì đối với cái bài toán hồi quy thì chúng ta sẽ có cái mô hình là hồi quy tuyến tính hay còn gọi là linear regression.
0:03:44 - 0:03:47, Và đối với cái bài toán phân loại thì chúng ta sẽ có hai tình huống.
0:03:47 - 0:03:53, Tình huống đầu tiên đó là phân loại nhị phân, tức là cái số phân lớp ca của mình là có hai phân lớp.
0:03:53 - 0:03:59, Và chúng ta sẽ có cái mô hình đó là hồi quy logistic hay là logistic regression.
0:03:59 - 0:04:08, Đối với trường hợp mà ca lớn hơn 2 thì đó sẽ là chúng ta sẽ có cái mô hình đó là hồi quy softmax hay còn gọi là softmax regression.
0:04:08 - 0:04:22, Còn trong cái trường hợp mà cái mô hình của mình phi tuyến tính thì chúng ta sẽ có rất nhiều những cái mô hình hiện đại tập trung vào giải quyết cái bài toán mà y của mình phụ thuộc một cách phi tuyến tính với là x đầu vào.
0:04:22 - 0:04:31, Và một trong những cái mô hình đầu tiên mà giải quyết cái bài toán mà có tính chất phi tuyến tính đó là mô hình Neural Network.
0:04:37 - 0:04:41, Neural Network hay còn gọi là mạng Neural Nhân tạo, ANN.
0:04:42 - 0:04:51, Thì đây có thể nói là một trong những cái mô hình đầu tiên để đặt nền móng cho học sâu.
0:04:51 - 0:04:57, Và các cái mô hình về sau thì chúng ta thấy nó có cái chữ A, có cái chữ NN, ví dụ như là CNN.
0:04:57 - 0:05:00, Thì cái chữ NN ở đây nó cũng chính là Neural Network.
0:05:00 - 0:05:05, Và còn ANN thì nó cũng có cái chữ NN là Neural Network.
0:05:05 - 0:05:14, Và thậm chí là Transformer thì rất nhiều những cái, kể cả Transformer thì rất nhiều những cái module ở trong Transformer
0:05:14 - 0:05:18, nó cũng dựa trên cái kiến trúc của Neural Network.
0:05:18 - 0:05:26, Do đó thì chúng ta mới gọi Neural Network là một trong những cái mô hình nền tảng đầu tiên về học sâu.
0:05:27 - 0:05:30, Và chúng ta sẽ đến với cái mô hình đầu tiên.
0:05:30 - 0:05:36, Đó là mô hình tuyến tính và giải quyết cho bài toán hồi quy.
0:05:36 - 0:05:38, Cụ thể đó là mô hình hồi quy tuyến tính.
0:05:38 - 0:05:48, Thì đây là cái dạng đồ thị của cái mạng, đây là cái dạng đồ thị của cái mô hình Linear Regression hồi quy tuyến tính.
0:05:48 - 0:05:51, Trong đó dữ kiện đầu vào sẽ là các cái đặc trưng.
0:05:51 - 0:05:57, Thì đặc biệt ở đây chúng ta sẽ thấy có một cái số 1, nó là tượng trưng cho cái bias,
0:05:57 - 0:06:00, cái giá trị bias.
0:06:00 - 0:06:05, Còn x1, x2, xm đó là các cái đặc trưng đầu vào,
0:06:05 - 0:06:12, các cái đặc trưng đầu vào để giúp cho chúng ta dự đoán cái giá trị đầu ra.
0:06:12 - 0:06:16, Thế thì câu hỏi là tại sao chúng ta phải có bias?
0:06:16 - 0:06:26, Bias sẽ đại diện cho toàn bộ những cái đặc trưng mà chúng ta không biết và không thống kê được trong m đặc trưng ở đây.
0:06:26 - 0:06:30, Tức là ngoài m đặc trưng này, nó sẽ có những cái đặc trưng nào đó nữa mà chúng ta không biết.
0:06:30 - 0:06:34, Thế thì tất cả những cái đặc trưng mà góp phần đưa ra cái giá trị dự đoán,
0:06:34 - 0:06:37, nó sẽ gom vào một cái đại lượng gọi là bias.
0:06:37 - 0:06:42, Ngoài ra với bias thì nó sẽ giúp cho mình chúng ta có khả năng biểu diễn linh hoạt hơn
0:06:42 - 0:06:48, với rất nhiều những cái dạng giá trị khác nhau, rất nhiều những cái dạng đường thẳng khác nhau.
0:06:48 - 0:06:57, Và cái hàm mô hình của mình là y ngã sẽ là bằng fθx, là nó sẽ có cái công thức đó là bằng theta chuyển vị nhân với x.
0:06:57 - 0:07:01, Thì đây chính là cái công thức mà dạng tuyến tính.
0:07:01 - 0:07:09, Trong đó thì cái đầu ra nó sẽ được nhân trọng số với các cái giá trị, với các cái đặc trưng đầu vào.
0:07:09 - 0:07:17, Thì ở đây chúng ta thấy là theta chính là cái tham số của cái mô hình là đặc trưng, là trọng số tương ứng với các cái đặc trưng.
0:07:17 - 0:07:21, Ví dụ theta ở đây nó sẽ là một cái vector.
0:07:21 - 0:07:30, Và vector này thì nó sẽ bao gồm là m cộng 1 chiều là theta 0 theta 1 cho đến theta m.
0:07:30 - 0:07:45, Thì theta 0 tương ứng là cái trọng số với bias, theta 1 là trọng số với đặc trưng x1, theta 2 tương ứng với trọng số x2,
0:07:45 - 0:07:49, và theta m là cái trọng số với đặc trưng xm.
0:07:49 - 0:07:55, Thì đây chính là cái công thức tổng, tổng có trọng số, chúng ta dùng cái ký hiệu tổng ở đây.
0:07:55 - 0:08:03, Và với cái giá trị đầu dự đoán y ngã thì chúng ta sẽ đi so sánh nó với lại cái y.
0:08:03 - 0:08:08, Chúng ta sẽ đi so sánh và chúng ta luôn mong muốn cái giá trị dự đoán này xấp xỉ y.
0:08:08 - 0:08:18, Thì cái công thức thể hiện cái dự đoán, cái sai số giữa cái dự đoán và cái thực tế thì chúng ta sẽ dùng cái công thức đó là tổng bình phương.
0:08:19 - 0:08:27, Với cái hàm lỗi này, chúng ta sẽ sử dụng cái thuật toán Backpropagation để đi huấn luyện.
0:08:27 - 0:08:32, Chúng ta sẽ có cái lỗi, từ hai cái này chúng ta sẽ tính ra được cái lỗi là G.
0:08:32 - 0:08:40, Từ G chúng ta sẽ lan truyền ngược đến đây, đến các cái trọng số này, để từ đó chúng ta sẽ cập nhật các cái trọng số.
0:08:40 - 0:08:51, Thế thì để làm việc chuyện đó chúng ta sẽ dùng công cụ đạo hàm và việc thiết kế cái mô hình của mình nó cũng phải đảm bảo nó có khả năng tính đạo hàm được.
0:08:51 - 0:09:03, Thì ở đây chúng ta thấy các thao tác là theta chuyển vị nhân với x, rồi theta x trừ y, đây đều là những cái hàm mà khả vi và có thể tính đạo hàm được.
0:09:03 - 0:09:07, Dẫn đến là thuật toán Backpropagation nó sẽ chạy được.
0:09:08 - 0:09:17, Rồi bây giờ chúng ta sẽ đến một cái tình huống trực quan, đó là giả sử như cái dữ liệu đầu vào của chúng ta chỉ có một đặc trưng là x thôi.
0:09:17 - 0:09:22, Và y của mình thì nó sẽ phụ thuộc một cách tuyến tính, đó là một cái hàm đồng biến.
0:09:22 - 0:09:33, Thì qua cái hàm này chúng ta sẽ tìm, nếu mà sau khi chúng ta huấn luyện xong và chúng ta tìm được thì chúng ta sẽ có được một cái đường đi xuyên qua các cái điểm dữ liệu này.
0:09:33 - 0:09:38, Và để đại diện cho cái đường này thì nó sẽ cần có cái tham số theta ở đây.
0:09:38 - 0:09:48, Tức là cái phương trình đường thẳng, cái phương trình đường thẳng này sẽ là cái phương trình dựa trên cái tham số ở bên đây.
0:09:48 - 0:10:00, Cụ thể đó là theta 0 cộng cho theta 1 x 1 cộng cho theta 2 x 2 v.v. là bằng 0.
0:10:00 - 0:10:10, Trong trường hợp này chúng ta chỉ có duy nhất một biến số, do đó thì nó sẽ là theta 0 cộng cho theta 1 x x bằng 0.
0:10:10 - 0:10:18, Thì đây chính là cái phương trình đường thẳng của cái đường mô hình đi qua các cái điểm khi mà đã được huấn luyện xong.
0:10:18 - 0:10:28, Thì trọng số, các cái trọng số này sẽ là cái trọng số, là cái tham số của cái phương trình đường thẳng này.
0:10:35 - 0:10:40, Rồi, chúng ta sẽ đến với cái mô hình thứ hai, đó là mô hình Logistic Regression.
0:10:40 - 0:10:45, Đây là một cái dạng mô hình tuyến tính dùng cho cái bài toán đó là phân loại, nhưng mà phân loại nhị phân.
0:10:45 - 0:10:48, Tức là số dạng đầu ra sẽ là 2.
0:10:49 - 0:10:53, Và mô hình này thì nó có dạng đồ thị như sau.
0:10:55 - 0:10:58, Và đây là cái đồ thị tính toán.
0:11:01 - 0:11:07, Rồi, thì cái y ngã, tức là cái giá trị dự đoán, nó sẽ là bằng sigmoid của theta x.
0:11:07 - 0:11:15, Thì chúng ta chú ý là trong cái Linear Regression, thì nó sẽ dừng ở đây.
0:11:17 - 0:11:22, Nhưng đối với mô hình Logistic Regression, nó sẽ có thêm một cái hàm sigmoid ở đây.
0:11:24 - 0:11:34, Thì nhờ có cái hàm sigmoid này, nó sẽ đưa cái giá trị output của mình về cái giải giá trị từ 0 cho đến 1.
0:11:35 - 0:11:43, Thì nếu như cái giá trị y ngã này thuộc về lớp 0, gần tiến gần về 0, thì nó sẽ thuộc về một lớp số 0.
0:11:44 - 0:11:49, Và nếu y ngã này lớn hơn 0.5, tiến về 1, thì cái nhãn của mình sẽ là 1.
0:11:50 - 0:11:59, Thì nhờ cái hàm sigmoid này, nó sẽ đưa về hai cái thái cực đó là 0 và 1 để giúp cho chúng ta phân loại đối tượng với đặc trưng đầu vào.
0:11:59 - 0:12:06, Thì cũng tương tự như là Linear Regression, chúng ta sẽ có bias và chúng ta sẽ có các đặc trưng input.
0:12:07 - 0:12:18, Và khi chúng ta đã tính ra được cái y ngã này rồi, thì chúng ta sẽ dùng cái công thức đó là hàm loss, hàm lỗi là bằng binary cross entropy.
0:12:19 - 0:12:24, Cái này là viết tắt của chữ binary cross entropy.
0:12:29 - 0:12:37, Giữa cái giá trị dự đoán, thì sigmoid của theta chuyển vị nhân x chính là giá trị dự đoán và cái giá trị thực tế.
0:12:38 - 0:12:49, Thế thì cái công thức binary cross entropy của mình, nếu như ở đây chúng ta ký hiệu gọn lại là y ngã, thì bce của y ngã và y,
0:12:49 - 0:13:01, thì nó sẽ có công thức đó là bằng trừ của y, log y ngã, cộng cho 1 trừ y nhân cho log của 1 trừ y ngã.
0:13:05 - 0:13:10, Và thì đây chính là cái công thức binary cross entropy, cái hàm loss, hàm lỗi của binary cross entropy.
0:13:10 - 0:13:24, Và khi chúng ta sử dụng cái mô hình logistic, hồi quy logistic thì các trọng số theta 0, theta 1, theta 2, theta m,
0:13:25 - 0:13:30, nó chính là trọng số để tạo ra phương trình đường thẳng này.
0:13:30 - 0:13:42, Và cụ thể luôn, cái phương trình đường thẳng này nó sẽ có cái dạng thức đó là theta 0, cộng cho theta 1, x1, cộng cho theta 2, x2.
0:13:43 - 0:13:55, Thì ở đây chúng ta có 2 cái đặc trưng thôi, nên chúng ta sẽ ghi công thức với 2 đặc trưng, nhưng mà một cách tổng quát thì nó có thể kéo đến theta m, xm là x bằng 0.
0:13:55 - 0:14:06, Và tất cả những cái điểm nào thuộc về một phía này thì khi chúng ta thế vào cái phương trình này, thế các cái đặc trưng x1 và x2 v.v. vào thì nó sẽ cùng dấu.
0:14:06 - 0:14:13, Ví dụ như ở đây sẽ là cùng dấu lớn hơn 0 và các cái điểm màu cam khi thế vào cái phương trình này thì nó sẽ là v.v.v.
0:14:13 - 0:14:22, Và những cái điểm nào nằm trên cái đường phân biên, phân cách này nè, cái đường phân loại 2 tập điểm này nè, thì nó sẽ là bằng 0.
0:14:22 - 0:14:31, Vì đó chính là cái ý nghĩa của mô hình Logistic Regression, ý nghĩa của các tham số liên quan đến cái đường boundary, cái đường phân biên giữa 2 tập điểm.
0:14:32 - 0:14:41, Và mô hình thứ 3, đó là cái mô hình tuyến tính và cho phân loại nhiều hơn 2 lớp, k lớn 2, thì chúng ta sẽ có mô hình softmax regression.
0:14:41 - 0:14:49, Và thay vì chúng ta có k phân lớp thì chúng ta sẽ có k giá trị, k giá trị là từ z1 cho đến zk.
0:14:49 - 0:14:55, Và ở đây sẽ có các lớp biến đổi tuyến tính làm tổng trọng số.
0:14:55 - 0:15:07, Tuy nhiên sau đó thì chúng ta sẽ qua 1 cái hàm softmax, k cái giá trị đầu vào qua cái hàm softmax, nó sẽ tạo ra k cái giá trị đầu ra là y ngã 1 cho đến y ngã k.
0:15:07 - 0:15:17, Và y ngã 1 cho đến y ngã k qua cái hàm softmax thì nó sẽ thỏa mãn tính chất đó là y ngã, y ngã k nhỏ thì lớn hơn 0 và bé hơn 1.
0:15:17 - 0:15:27, Và tổng của y ngã k thì là bằng 1 với k chạy từ 1 cho đến k lớn, k lớn là số phân lớp của mình.
0:15:27 - 0:15:31, Thì đây chính là một cái biểu diễn cho cái không gian xác suất.
0:15:31 - 0:15:41, Trong cái không gian xác suất thì các cái giá trị của mình nó sẽ nhận giá trị từ 0 cho đến 1 và tổng là bằng 1.
0:15:41 - 0:15:47, Thế thì nếu giá trị nào lớn nhất thì đó sẽ thuộc về cái lớp tương ứng.
0:15:47 - 0:15:50, Và cái hàm lỗi ở đây chúng ta sẽ đi so sánh.
0:15:50 - 0:15:57, Chúng ta sẽ mong muốn là k cái giá trị này nó sẽ xấp xỉ với lại y1, y2 và yk.
0:15:57 - 0:16:03, Thế thì để cho k cái giá trị này nó xấp xỉ nhau thì chúng ta sẽ sử dụng hàm cross entropy.
0:16:04 - 0:16:12, Thế thì giả sử như cái softmax của cái theta chuyển vị, theta chuyển vị nhân x thì chúng ta ký hiệu là y ngã.
0:16:12 - 0:16:26, Thì khi đó chúng ta sẽ có công thức đó là cross entropy của y ngã và y thì nó sẽ là bằng trừ của tổng với k chạy từ 1 cho đến k lớn.
0:16:26 - 0:16:34, K lớn chính là số lớp và y log y ngã k.
0:16:34 - 0:16:42, Thì đây chính là cái công thức cross entropy với y ngã là cái công thức mà viết gọn lại của softmax theta chuyển vị k.
0:16:42 - 0:16:52, Thế thì về mặt trực quan thì trong trường hợp mà chúng ta có nhiều cái phân lớp thì cái đường boundary mà giúp cho chúng ta phân biệt 4 cái lớp này.
0:16:52 - 0:17:04, Cái đường như thế này nó sẽ tách ra làm 4 phần thì nó sẽ không có tình trạng 1 điểm thì nó sẽ không thuộc về cái phần nào.
0:17:04 - 0:17:12, Ví dụ như với 1 điểm ở đây thì chúng ta dựa trên cái đường phân biên này chúng ta sẽ biết nó sẽ thuộc về cái lớp xanh lá.
0:17:12 - 0:17:16, Rồi cái điểm ở đây thì nó sẽ thuộc về cái lớp màu vàng.
0:17:16 - 0:17:20, Thì đó chính là hồi quy softmax.