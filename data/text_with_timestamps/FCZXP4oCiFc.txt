00:00:00 - 00:00:18, Chúng ta sẽ cùng đến với phần thực hành thuật toán Radiant Ascent
00:00:18 - 00:00:27, Đây là sơ đồ thuật toán của Radiant Ascent phiên bản đầu tiên
00:00:27 - 00:00:33, Tham số là theta
00:00:33 - 00:00:43, Theta có một giá trị ngộn nhiên, tình hình như số 1, số 12, v.v.
00:00:43 - 00:00:51, Chúng ta sẽ sử dụng hàm một biến là J theta
00:00:51 - 00:00:57, Hàm này là một dạng hàm mà có một điểm cực tiểu
00:00:57 - 00:01:08, Khi xang tình huống phức tạp hơn, chúng ta sẽ cài đặt bằng biến thể momentum
00:01:08 - 00:01:20, Vì vậy, chúng ta sẽ chọn một hàm đơn giản để thực hành
00:01:20 - 00:01:33, Vì vậy, chúng ta sẽ chọn một hàm đơn giản để thực hành
00:01:33 - 00:01:38, Sau đó, chúng ta sẽ tiến hành lập trình
00:01:38 - 00:01:42, Trong quá trình lập trình, chúng ta sẽ có một số tham số mơ lưới
00:01:42 - 00:01:46, Ví dụ như là tham số alpha
00:01:46 - 00:01:49, Đây là siêu tham số
00:01:49 - 00:01:57, Alpha cũng khởi tạo bằng một con số khá bé, ví dụ như là 0.01
00:01:57 - 00:02:01, Chúng ta thấy có xuất hiện hai biến là theta new và theta old
00:02:01 - 00:02:05, Thực ra, chúng ta không cần tạo hai biến new và biến old này
00:02:05 - 00:02:09, Theta là bằng theta trừ cho alpha nhân cho đạo hàm
00:02:09 - 00:02:16, Thì nó đã tự động cập nhật biến theta vào trong giá trị mới cho biến theta
00:02:16 - 00:02:21, Bây giờ, chúng ta sẽ tiến hành những bước lập trình đầu tiên
00:02:21 - 00:02:26, Chúng ta sẽ qua giao diện code
00:02:26 - 00:02:29, Chúng ta sẽ import
00:02:29 - 00:02:33, Chúng ta sẽ tạo ra một file nama GradientDescent
00:02:33 - 00:02:37, Import Numpy
00:02:37 - 00:02:41, SNP
00:02:41 - 00:02:58, Chúng ta sẽ có một bước khởi tạo các tham số và siêu tham số
00:02:58 - 00:03:03, Chúng ta sẽ có theta bằng số 12
00:03:03 - 00:03:08, Alpha là 0.01
00:03:08 - 00:03:15, Trong sơ đồ, chúng ta sẽ phải khởi tạo hàm j
00:03:15 - 00:03:21, Chúng ta sẽ có thêm hàm j của theta
00:03:21 - 00:03:32, Chúng ta sẽ return là 5 nhân cho theta mũ 2 trừ cho 8 nhân cho theta cộng 3
00:03:32 - 00:03:38, Sau đó, chúng ta sẽ đến bước tính đạo hàm
00:03:38 - 00:03:41, Chúng ta đã xong bước này rồi
00:03:41 - 00:03:44, Chúng ta sẽ đến bước tính đạo hàm
00:03:44 - 00:03:49, Thì tính đạo hàm của hàm ở trên sẽ có công thức luôn
00:03:49 - 00:03:52, Thay vì chúng ta dùng công thức định nghĩa đạo hàm
00:03:52 - 00:04:00, Chúng ta vẫn dùng các bảng tra, các công thức tính đạo hàm cho hàm đa thức, hàm hợp, v.v.
00:04:00 - 00:04:02, Để chúng ta tính trực tiếp
00:04:02 - 00:04:04, Gph cho nó đơn giản
00:04:04 - 00:04:10, Gph sẽ là bằng 10 theta trừ cho 8
00:04:10 - 00:04:15, Sau đó, chúng ta sẽ tiến hành cài đặt hàm chí phải
00:04:26 - 00:04:31, Chúng ta sẽ return là 10 nhân cho theta trừ cho 8
00:04:31 - 00:04:36, Sau đó, chúng ta sẽ tiến hành cập nhật tham số
00:04:36 - 00:04:43, Chúng ta thấy là bảng chất là một vòng lập lập đi lập lại tính đạo hàm
00:04:43 - 00:04:45, thực hiện đi thực hiện lại bước này
00:04:45 - 00:04:48, Chúng ta sẽ tạo một vòng lập y
00:04:48 - 00:04:53, Chúng ta không biết trước số vòng lập nên chúng ta sẽ để y trung
00:04:53 - 00:05:02, Mình sẽ gọi hàm tính đạo hàm là derivative là bằng chi của theta
00:05:02 - 00:05:13, Sau đó, chúng ta sẽ có công thức là theta là bằng theta trừ cho alpha nhân với lại đạo hàm
00:05:13 - 00:05:17, Vòng lập này khi nào thì nó dừng
00:05:17 - 00:05:26, Khi tham số của mình tiến về điểm cực tiểu
00:05:26 - 00:05:33, Khi tiến về điểm cực tiểu, đạo hàm của j là xấp xỉ bằng không
00:05:33 - 00:05:40, Tại vì đạt điểm cực tiểu thì hệ số góc này là xâm xong với lại trục ox
00:05:40 - 00:05:42, Tức là đạo hàm xấp xỉ bằng không
00:05:42 - 00:05:51, Vì vậy, điều kiện dừng của mình là if theta is derivative là đủ nhỏ
00:05:51 - 00:05:53, Tại vì nó không thể nào bằng không được
00:05:53 - 00:05:59, Tại vì trong quá trình vũ tán, nó sẽ có sai số
00:05:59 - 00:06:02, Và ở đây chúng ta sẽ phải dùng trị thực đối
00:06:02 - 00:06:05, Tại vì nó sẽ có tình huống là đạo hàm nó âm và đạo hàm nó dương
00:06:05 - 00:06:07, Nhưng mà nó tiến về số 0
00:06:07 - 00:06:09, Do đó mình phải dùng trị thực đối
00:06:09 - 00:06:11, Và ở đây chúng ta sẽ xuất hiện thêm một cái biến nữa
00:06:11 - 00:06:13, Đó là biến epsilon
00:06:13 - 00:06:18, Và ở đây chúng ta sẽ xuất hiện 1 break
00:06:18 - 00:06:20, Và ở đây chúng ta sẽ xuất hiện 1 break
00:06:20 - 00:06:28, Rồi, thì ở đây chúng ta sẽ thêm một biến nữa là eps là bằng 0.001 là một con số rất là nhỏ
00:06:28 - 00:06:32, Rồi, bây giờ chúng ta sẽ in cái kết quả ra
00:06:32 - 00:06:36, Đó là theta tối ưu
00:06:36 - 00:06:40, Thì nó sẽ là in ra cái theta
00:06:41 - 00:06:45, Rồi, bây giờ chúng ta sẽ chạy cái đoạn code này
00:06:45 - 00:06:47, Chúng ta sẽ chạy cái đoạn code này
00:06:47 - 00:06:56, Bằng cách đó là chúng ta control ship pair chọn cái interpreter là con đa
00:06:56 - 00:07:00, Rồi, sau đó chúng ta sẽ run
00:07:00 - 00:07:04, Thì ở đây là chưa có cái thư viện lumpy
00:07:04 - 00:07:09, Do đó thì chúng ta sẽ pip install
00:07:09 - 00:07:21, Rồi, sau đó chúng ta sẽ chạy cái code này lại
00:07:21 - 00:07:26, Thì chúng ta thấy là cái theta tối ưu chạy rất là nhanh
00:07:26 - 00:07:30, Và theta tối ưu là sắp xỉ bằng 8
00:07:30 - 00:07:37, Thế thì bây giờ chúng ta làm sao kiểm tra xem cái theta này có đúng là bằng 8 hay không
00:07:37 - 00:07:40, Thì chúng ta sẽ quay trở lại cái slide của mình
00:07:40 - 00:07:45, Trong cái công thức ở trên thì cái giá trị nhỏ nhất
00:07:45 - 00:07:49, Đó là đạt được khi bằng b chia cho 2a
00:07:49 - 00:07:51, Tức là bằng trừ b chia cho 2a
00:07:51 - 00:07:56, Tức là bằng trừ của trừ 8 chia cho 2a
00:07:56 - 00:08:00, A ở đây là 5, 2 x 5 là bằng 10
00:08:00 - 00:08:04, Tức là bằng 8 phần 10 tức là bằng 0.8
00:08:04 - 00:08:09, Như vậy thì cái đáp số của mình là hoàn toàn chính xác
00:08:09 - 00:08:12, Sau khi chúng ta chạy với thực tán Radiant Descent
